# AGENTS.md

 0) Non-negotiable Locality Envelope (default)
 - Vanilla-first: prefer platform primitives; default to vanilla first, and only use frameworks if justified.
 - Dependency budget: 0 by default; max 1-2 per concern, only if justified.
 - File budget: Fewer is better. Create as fewer files as possible to achieve production-grade quality without creating context overwhelm (zero unnecesary files).
 - LOC budget: target ≤ 1000 LOC/file; split when > 2000 LOC. Avoid “context rot” growth.
 - Every Plan offered must explicitly state: {files, LOC/file, deps}.


 1) Role routing (global)
 - When doing backend development always follow the LLM_FRIENDLY_ENGINEERING_BACKEND instructions.
 - When doing frontend design always follow the LLM_FRIENDLY_ENGINEERING_FRONTEND instructions.
 - When planning or debugging always follow the LLM_FRIENDLY_PLAN_TEST_DEBUG instructions.



LLM_FRIENDLY_ENGINEERING_BACKEND
	"""
	Backend coding: When building software, organize all code by feature into vertical slices where interface, logic, schema, validation, and tests live together in immediate proximity—never scatter related concerns across distant directories or technical layers. Default to language primitives and standard libraries (vanilla-first mandate) before introducing any external dependency, and when dependencies prove necessary, assign exactly one tool per architectural concern, wrapping specialized libraries in thin adapter interfaces that isolate external complexity at system edges. Keep files purposeful and focused, naming them with boring descriptive terminology, and promote code to shared locations only after the rule of three (genuine reuse appears three times) proves the pattern stable. Define explicit schema-validated contracts at every feature boundary, validating all inputs at entry and shaping all outputs at exit using uniform error models that include status, code, message, and optional details without leaking implementation specifics. Confine singletons (database clients, cache clients, auth providers, config loaders, logging systems) strictly to infrastructure zones as stateless factories, never embedding domain logic within them. Limit build operations to essential commands (install, develop, test, build, start) with pinned dependencies ensuring deterministic reproducible builds, and implement structured feature-scoped logging with request correlation for operational transparency. Write unit tests for key pure functions, end-to-end tests for critical paths, and contract tests for boundary schemas, co-locating all tests with the code they validate. Target established accessibility compliance standards with keyboard-first interaction, visible focus states, reduced motion respect, and appropriate ARIA roles, while centralizing design tokens (color, spacing, typography, radius, motion) in exactly one style system per project. Begin architecture as a simple monolith of vertical slices, extracting async work to background jobs only when genuine need arises, creating shared packages only after cross-feature reuse stabilizes, and splitting into services only when isolation, scaling, or compliance boundaries are demonstrated through measured metrics. When refactoring, inline logic toward callers before extracting abstractions, consolidate fragmented files into coherent feature folders, and write or update contracts before changing implementation—replacing unnecessary libraries with vanilla implementations and removing abstractions that no longer provide value. Reject utility collections mixing unrelated concerns, code fragmentation into many tiny files increasing navigation cost, duplicate tools serving identical purposes, implicit global state, reflection-heavy patterns obscuring behavior, and any framework with sparse documentation on critical paths. Ensure every deliverable constitutes a self-contained feature slice with adjacent schema and tests, confining global concerns to singleton adapters without domain logic, providing run instructions fitting three lines producing deterministic results, and documenting selected tools while verifying they meet documentation and predictability thresholds. Present options briefly with clear default recommendations, state assumptions explicitly and proceed without unnecessary blocking, produce small copyable immediately-runnable artifacts, prefer diagrams and checklists before implementation code, generate code in vertical slices rather than global sweeps, refactor incrementally while preserving existing contracts, and ensure every artifact reaches completeness enabling immediate utility. Measure success by minimizing files and directories touched per feature change, maintaining file sizes within productive ranges, achieving high boundary coverage with explicit schemas, keeping local startup and hot-reload times minimal, referencing canonical documentation sources, maintaining high API predictability ratings, providing runnable copy-pasteable snippets for common operations, and maximizing the ratio of vanilla code paths to dependency-heavy paths—where ultimate validation asks whether a competent reader (human or AI agent with LLM capabilities performing code generation and modification tasks) can understand, modify, and extend the system correctly on first encounter without external context, preferring locality over abstraction, explicitness over cleverness, and simplicity over sophistication in every decision.
	"""
END_LLM_FRIENDLY_ENGINEERING_BACKEND

LLM_FRIENDLY_ENGINEERING_FRONTEND
	"""
	Frontend design: When designing frontend interfaces, first identify and explicitly blacklist all high-probability solutions (Inter/Roboto/Open-Sans/Arial/system-fonts, purple-white gradients, centered hero layouts with stock imagery, evenly-distributed safe palettes, uniform spacing rhythms, generic card grids, predictable button hierarchies, anything describable as "clean-and-modern") treating statistical convergence as failure signal rather than safety indicator. After eliminating the obvious, navigate toward latent space edges where distinctive memorable solutions exist by committing fully to a singular aesthetic stance combining typography (font-choice defining voice and hierarchy through unconventional pairings or single-typeface systems with extreme weight contrast), color (palettes rejecting safety through unexpected combinations, restricted ranges, or intentional dissonance that creates visual tension), spatial composition (asymmetry, unexpected density variations, deliberate negative space manipulation, rhythm breaks that demand attention), and motion (purposeful animation revealing state changes, guiding attention, or reinforcing brand character without decorative excess). Every choice must satisfy the defensibility test: solve the actual problem equally-well or better while being categorically non-generic, meaning if the output would blend invisibly into a corpus of similar interfaces reject and regenerate, ensuring the result remains immediately recognizable as deliberately designed rather than template-generated. Maintain accessibility requirements (keyboard navigation, focus states, ARIA semantics, color-contrast ratios, reduced-motion respect) as non-negotiable constraints within which creative decisions operate, and ensure all interactive elements provide clear affordances through visual distinction rather than convention-mimicry. Organize component architecture by feature-locality principles where styling logic lives adjacent to component implementation, centralizing design tokens (but rejecting token systems that enforce homogeneity) and documenting aesthetic rationale inline so future modifications preserve intentional distinctiveness. Test every visual decision against recognition criteria: would a user remember this interface after brief exposure, does it communicate brand or purpose through design choices rather than explicit messaging, and does it resist the gravitational pull toward generic-pleasant mediocrity that dominates training distributions.
	"""
END_FRIENDLY_ENGINEERING_FRONTEND

LLM_FRIENDLY_PLAN_TEST_DEBUG
	"""
	When planning software with LLM-teams and human operators, structure all work into discrete feature-phases (complete vertical slices delivering specific capabilities) executed one-shot in a single turn, followed by testscripts executed in one-shot to validate, debug, iterate, and polish each phase. Begin every engagement by capturing the complete environment matrix (operating-system, runtime-versions, tool-versions, build-identifiers, configuration-flags) and non-functional requirements (latency-targets, memory-ceilings, reliability-thresholds, security-boundaries) as Phase-Zero context, then produce a feature-phase breakdown with explicit sequencing, dependencies, and pass-fail criteria where each phase includes its deliverable scope, testscript structure (identifier, objective, prerequisites, setup-steps, run-commands, expected-observations at each boundary, artifact-capture points with formats, cleanup-procedures, known-limitations), and observation checklist (environment-details, exact-steps-executed, observed-versus-expected comparisons, artifact-paths-and-timestamps, reproducibility-frequency). Execute feature-phases one-shot by implementing all phases with structured-logging at boundaries and error-paths (using standard-error-envelopes containing status-code-message-context), explicit-input-validation, deterministic one-command-setup with pinned-versions, and instrumentation that surfaces correlation-identifiers across all boundaries—delivering immediately-runnable code that makes cold-start, execution, and teardown reproducible without hidden-behavior or silent-failures. After one-shot completion, execute testscripts one-shot in the real runtime environment (browser, server, device, full-stack) rather than detached-unit-scaffolds, where each testscript runs the actual-application with whole-system-behavior-verification, re-executing all prior-phases' testscripts at each feature-phase to detect regressions before proceeding, ensuring no phase advances without satisfying current-criteria and confirming no collateral-damage to previously-passing validations. When failures occur during testscript execution, create minimal-reproducers without altering semantics, instrument observation-points before editing code, form one-hypothesis and change one-variable per iteration, classify defects to specific boundaries using systematic root-cause categorization (environment-mismatch, dependency-drift, configuration-gaps, contract-mismatches, stateful-side-effects, timing-races, resource-limits, filesystem-semantics, network-factors, clock-timeouts, data-corruption, test-production-divergence), apply the smallest-most-local-fix possible, prove fixes with reproducer-then-full-testscript, and add regression-checks to prevent recurrence—issuing minimal-targeted-data-requests (specifying exact-artifact-locations, formats, collection-commands) rather than broad-fishing-expeditions, stopping after two-failed-attempts to generate a failure report, request new-specific-observations and reformulate-hypotheses instead of blind-retries. Define clear role-separation where LLM-teams produce immediately-runnable plans and code with complete testscripts and observation-checklists, own triage-hypothesis-fix-regression-creation, emit structured-errors and actionable-diagnostics by default, and issue minimal-targeted-requests when evidence insufficient, while human-operators execute specified-testscripts faithfully, capture-and-attach requested-artifacts precisely at collection-points, confirm environment-details and note deviations, follow checklists without deviation-or-interpretation, and avoid speculative-debugging or root-cause-guessing. Implement progressive-validation-depth covering smoke-level (boot, wiring, signal-visibility), happy-path (nominal-journeys with contract-verification), edge-cases (boundary-values and unusual-supported-inputs), failure-paths (meaningful-errors and fallbacks), recovery (reset-retry-idempotency-degradation), budget (latency-throughput-memory-resource-limits), and security (authentication-authorization-input-hardening), never skipping fundamental-levels for advanced-ones or considering happy-path-alone sufficient for production-readiness. Consolidate all passing-testscripts into persistent-regression-suites integrated into continuous-integration or scheduled-execution, adding assertions from every passing-test and creating new-checks from every-failure, prioritizing flaky-test-stabilization as critical-work, and maintaining documented pass-rate-thresholds with execution-time-budgets appropriate to project-scale. Redact secrets, personal-data, and tokens at all collection-points, provide explicit safe-sharing-guidance for artifacts, respect least-privilege when reproducing defects, and never expose sensitive-data in logs-artifacts-or-defect-reports. Structure all defect-reports with required-fields (title, severity, frequency, phase, script-identifier, environment-matrix, build-commit, reproduction-steps, observed-behavior, expected-behavior, artifact-references, suspected-boundary, initial-hypothesis, workaround-if-available, regression-test-status, ownership) sufficient for first-attempt-diagnosis, documenting root-cause with cause-fix-prevention-measures before closure. Keep beginner-defaults simple: single-run-commands for environment-setup, fewer-but-whole-application-tests rather than proliferated-unit-tests, boundary-instrumentation-first with correlation-identifiers, regression-checks-added whenever defects-fixed, and vanilla-implementations that maximize reasoning-clarity over complex-tooling. Measure success by whether a single-guided-run by a non-expert-operator provides enough structured-evidence for definitive-diagnosis-and-fix on first-attempt, validating through metrics including reproducibility-rate on first-observation, time-from-run-start to first-meaningful-signal, convergence-speed after targeted-data-collection, ratio of non-deterministic-failures, completeness of defect-reports with all-required-fields, and protection-coverage of critical-boundaries aligned to prior-incidents. Once a planning engagement is concluded, proceed immediately to one-shot both the feature-phases and testscripts, ensuring that every-deliverable must be immediately-runnable, observable, and debuggable without requiring extensive-interpretation or multi-step-completion-work.
	"""
END_LLM_FRIENDLY_PLAN_TEST_DEBUG